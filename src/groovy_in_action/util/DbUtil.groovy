package groovy_in_action.util

@Grab('org.hsqldb:hsqldb:2.4.0')
@GrabConfig(systemClassLoader = true)
import groovy.sql.Sql
import org.hsqldb.jdbc.JDBCDataSource

class DbUtil {

    static Sql create() {
        def dataSource = new JDBCDataSource(
                database: 'jdbc:hsqldb:mem:GinA', user: 'sa', password: '')
        def sql = new Sql(dataSource)

        sql.execute '''
          DROP TABLE Athlete IF EXISTS cascade;
          DROP TABLE Record IF EXISTS;
        '''

        sql.execute '''
          CREATE TABLE Athlete (
            athleteId   INTEGER GENERATED BY DEFAULT AS IDENTITY,
            firstname   VARCHAR(64),
            lastname    VARCHAR(64),
            dateOfBirth DATE,
            UNIQUE(athleteId)
          );
        '''

        sql.execute '''
          CREATE TABLE Record (
            recordId  INTEGER GENERATED BY DEFAULT AS IDENTITY,
            time      INTEGER, -- in seconds
            venue     VARCHAR(64),
            whenRun   DATE,
            fkAthlete INTEGER,
            CONSTRAINT fk FOREIGN KEY (fkAthlete)
              REFERENCES Athlete (athleteId) ON DELETE CASCADE
          );
        '''

        sql
    }

    static insertAthlete(Sql sql, String firstname, String lastname, String dateOfBirth) {
        def insertSql = '''
          INSERT INTO Athlete (firstname, lastname, dateOfBirth)
            VALUES (?, ?, ?);
        '''
        sql.executeInsert insertSql, [firstname, lastname, dateOfBirth]
    }

    static def insertRecord(Sql sql, h, m, s, venue, date, lastname) {
        def time = h*60*60 + m*60 + s
        sql.execute """
          INSERT INTO Record (time, venue, whenRun, fkAthlete)
            SELECT $time, $venue, $date, athleteId FROM Athlete WHERE lastname = $lastname;
        """
    }

    static populate(Sql sql) {
        /*********************/
        /* insert operations */
        /*********************/

        // HSQLDB starts auto-generated values from zero and increments by one, so the
        // second row will have 1 and the third row 2.

        /* Inserts using plain statement */

        sql.execute '''
          INSERT INTO Athlete (firstname, lastname, dateOfBirth)
                        VALUES ('Paul',    'Tergat', '1969-06-17');
        '''


        /* GString variant: prepared statement with placeholder */

        def data = [first: 'Khalid', last: 'Khannouchi', birth: '1971-12-22']

        // Pay attention to the tripled double quotes around the statement, and
        // remember that this construction produces a prepared statement and will
        // therefore be just as efficient and safe on the database as the question-mark
        // version (indeed that's what it's turned into under the covers).
        def keys = sql.executeInsert """
          INSERT INTO Athlete (firstname, lastname, dateOfBirth)
            VALUES (${data.first}, ${data.last}, ${data.birth});
        """
        // Checks generated keys for second row
        assert keys[0] == [1]


        /* prepared statement */

        def insertSql = '''
          INSERT INTO Athlete (firstname, lastname, dateOfBirth)
                        VALUES (?, ?, ?);
        '''
        def params = [ 'Ronaldo', 'da Costa', '1970-06-07']
        def keyColumnNames = ['ATHLETEID']
        // List of params variant
        keys = sql.executeInsert insertSql, params, keyColumnNames
        // Checks generated athleteId key for third row
                assert keys[0] == ['ATHLETEID': 2]


        /***********/
        /* Records */
        /***********/

        insertRecord(sql, 2, 4, 55, 'Berlin', '2003-09-28', 'Tergat')
        insertRecord(sql, 2, 5, 38, 'London', '2002-04-14', 'Khannouchi')
        insertRecord(sql, 2, 5, 42, 'Chicago', '1999-10-24', 'Khannouchi')
        insertRecord(sql, 2, 6, 05, 'Berlin', '1998-09-20', 'da Costa')
    }

}